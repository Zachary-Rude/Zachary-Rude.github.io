<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <title>My GitHub Pages Website</title>
    <link href="css/terminal.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <header>
      <nav>
        <ul>
          <li><a class="active">Home</a></li>
          <li><a href="Linux-Terminal">Linux Terminal</a></li>
          <li><a href="Python-Shell">Python Shell</a></li>
        </ul>
      </nav>
      <h1>My GitHub Pages Website</h1>
    </header>
    <p>
      Come here and explore!
    </p>
    <p>
      <strong>
        WITH...
      </strong>
    </p>
    <img src="https://storage.googleapis.com/replit/images/1626663313025_930cd958ef6b188c58666994acd4b784.png" alt="My Linux Terminal" />
    <br>
    <a href="Linux-Terminal">A Linux terminal</a>
    <br>
    <img src="data:image/jpeg;base64,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" alt="Google's 404 Web Page" />
    <p>
      A Custom 404 Web Page
    </p>
    <p>
      ... and many others.
    </p>
    <hr>
    <footer>
      <p>
        <small>
          Copyright &copy; 2021, By Zachary Rude, All Rights Reserved.
        </small>
      </p>
    </footer>
    <script type="text/javascript">
      (function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.Zooming = factory());
}(this, function () { 'use strict';

  var cursor = {
    default: 'auto',
    zoomIn: 'zoom-in',
    zoomOut: 'zoom-out'
  };

  function listen(el, event, handler) {
    var add = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    var options = { passive: false };

    if (add) {
      el.addEventListener(event, handler, options);
    } else {
      el.removeEventListener(event, handler, options);
    }
  }

  function loadImage(src, cb) {
    if (src) {
      var img = new Image();

      img.onload = function onImageLoad() {
        if (cb) cb(img);
      };

      img.src = src;
    }
  }

  function getOriginalSource(el) {
    if (el.dataset.original) {
      return el.dataset.original;
    } else if (el.parentNode.tagName === 'A') {
      return el.parentNode.getAttribute('href');
    } else {
      return null;
    }
  }

  function setStyle(el, styles, remember) {
    if (styles.transition) {
      var value = styles.transition;
      delete styles.transition;
      styles.transition = value;
    }

    if (styles.transform) {
      var _value = styles.transform;
      delete styles.transform;
      styles.transform = _value;
    }

    var s = el.style;
    var original = {};

    for (var key in styles) {
      if (remember) {
        original[key] = s[key] || '';
      }

      s[key] = styles[key];
    }

    return original;
  }

  function bindAll(_this, that) {
    var methods = Object.getOwnPropertyNames(Object.getPrototypeOf(_this));
    methods.forEach(function bindOne(method) {
      _this[method] = _this[method].bind(that);
    });
  }

  var noop = function noop() {};

  var DEFAULT_OPTIONS = {
    /**
     * To be able to grab and drag the image for extra zoom-in.
     * @type {boolean}
     */
    enableGrab: false,

    /**
     * Preload zoomable images.
     * @type {boolean}
     */
    preloadImage: false,

    /**
     * Close the zoomed image when browser window is resized.
     * @type {boolean}
     */
    closeOnWindowResize: true,

    /**
     * Transition duration in seconds.
     * @type {number}
     */
    transitionDuration: 0.4,

    /**
     * Transition timing function.
     * @type {string}
     */
    transitionTimingFunction: 'cubic-bezier(0.4, 0, 0, 1)',

    /**
     * Overlay background color.
     * @type {string}
     */
    bgColor: 'rgb(255, 255, 255)',

    /**
     * Overlay background opacity.
     * @type {number}
     */
    bgOpacity: 1,

    /**
     * The base scale factor for zooming. By default scale to fit the window.
     * @type {number}
     */
    scaleBase: 1.0,

    /**
     * The additional scale factor when grabbing the image.
     * @type {number}
     */
    scaleExtra: 0.5,

    /**
     * How much scrolling it takes before closing out.
     * @type {number}
     */
    scrollThreshold: 40,

    /**
     * The z-index that the overlay will be added with.
     * @type {number}
     */
    zIndex: 998,

    /**
     * Scale (zoom in) to given width and height. Ignore scaleBase if set.
     * Alternatively, provide a percentage value relative to the original image size.
     * @type {Object|String}
     * @example
     * customSize: { width: 800, height: 400 }
     * customSize: 100%
     */
    customSize: null,

    /**
     * A callback function that will be called when a target is opened and
     * transition has ended. It will get the target element as the argument.
     * @type {Function}
     */
    onOpen: noop,

    /**
     * Same as above, except fired when closed.
     * @type {Function}
     */
    onClose: noop,

    /**
     * Same as above, except fired when grabbed.
     * @type {Function}
     */
    onGrab: noop,

    /**
     * Same as above, except fired when moved.
     * @type {Function}
     */
    onMove: noop,

    /**
     * Same as above, except fired when released.
     * @type {Function}
     */
    onRelease: noop,

    /**
     * A callback function that will be called before open.
     * @type {Function}
     */
    onBeforeOpen: noop,

    /**
     * A callback function that will be called before close.
     * @type {Function}
     */
    onBeforeClose: noop,

    /**
     * A callback function that will be called before grab.
     * @type {Function}
     */
    onBeforeGrab: noop,

    /**
     * A callback function that will be called before release.
     * @type {Function}
     */
    onBeforeRelease: noop,

    /**
     * A callback function that will be called when the hi-res image is loading.
     * @type {Function}
     */
    onImageLoading: noop,

    /**
     * A callback function that will be called when the hi-res image is loaded.
     * @type {Function}
     */
    onImageLoaded: noop
  };

  var PRESS_DELAY = 200;

  var handler = {
    init: function init(instance) {
      bindAll(this, instance);
    },
    click: function click(e) {
      e.preventDefault();

      if (isPressingMetaKey(e)) {
        return window.open(this.target.srcOriginal || e.currentTarget.src, '_blank');
      } else {
        if (this.shown) {
          if (this.released) {
            this.close();
          } else {
            this.release();
          }
        } else {
          this.open(e.currentTarget);
        }
      }
    },
    scroll: function scroll() {
      var el = document.documentElement || document.body.parentNode || document.body;
      var scrollLeft = window.pageXOffset || el.scrollLeft;
      var scrollTop = window.pageYOffset || el.scrollTop;

      if (this.lastScrollPosition === null) {
        this.lastScrollPosition = {
          x: scrollLeft,
          y: scrollTop
        };
      }

      var deltaX = this.lastScrollPosition.x - scrollLeft;
      var deltaY = this.lastScrollPosition.y - scrollTop;
      var threshold = this.options.scrollThreshold;

      if (Math.abs(deltaY) >= threshold || Math.abs(deltaX) >= threshold) {
        this.lastScrollPosition = null;
        this.close();
      }
    },
    keydown: function keydown(e) {
      if (isEscape(e)) {
        if (this.released) {
          this.close();
        } else {
          this.release(this.close);
        }
      }
    },
    mousedown: function mousedown(e) {
      if (!isLeftButton(e) || isPressingMetaKey(e)) return;
      e.preventDefault();
      var clientX = e.clientX,
          clientY = e.clientY;


      this.pressTimer = setTimeout(function grabOnMouseDown() {
        this.grab(clientX, clientY);
      }.bind(this), PRESS_DELAY);
    },
    mousemove: function mousemove(e) {
      if (this.released) return;
      this.move(e.clientX, e.clientY);
    },
    mouseup: function mouseup(e) {
      if (!isLeftButton(e) || isPressingMetaKey(e)) return;
      clearTimeout(this.pressTimer);

      if (this.released) {
        this.close();
      } else {
        this.release();
      }
    },
    touchstart: function touchstart(e) {
      e.preventDefault();
      var _e$touches$ = e.touches[0],
          clientX = _e$touches$.clientX,
          clientY = _e$touches$.clientY;


      this.pressTimer = setTimeout(function grabOnTouchStart() {
        this.grab(clientX, clientY);
      }.bind(this), PRESS_DELAY);
    },
    touchmove: function touchmove(e) {
      if (this.released) return;

      var _e$touches$2 = e.touches[0],
          clientX = _e$touches$2.clientX,
          clientY = _e$touches$2.clientY;

      this.move(clientX, clientY);
    },
    touchend: function touchend(e) {
      if (isTouching(e)) return;
      clearTimeout(this.pressTimer);

      if (this.released) {
        this.close();
      } else {
        this.release();
      }
    },
    clickOverlay: function clickOverlay() {
      this.close();
    },
    resizeWindow: function resizeWindow() {
      this.close();
    }
  };

  function isLeftButton(e) {
    return e.button === 0;
  }

  function isPressingMetaKey(e) {
    return e.metaKey || e.ctrlKey;
  }

  function isTouching(e) {
    e.targetTouches.length > 0;
  }

  function isEscape(e) {
    var code = e.key || e.code;
    return code === 'Escape' || e.keyCode === 27;
  }

  var overlay = {
    init: function init(instance) {
      this.el = document.createElement('div');
      this.instance = instance;
      this.parent = document.body;

      setStyle(this.el, {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        opacity: 0
      });

      this.updateStyle(instance.options);
      listen(this.el, 'click', instance.handler.clickOverlay.bind(instance));
    },
    updateStyle: function updateStyle(options) {
      setStyle(this.el, {
        zIndex: options.zIndex,
        backgroundColor: options.bgColor,
        transition: 'opacity\n        ' + options.transitionDuration + 's\n        ' + options.transitionTimingFunction
      });
    },
    insert: function insert() {
      this.parent.appendChild(this.el);
    },
    remove: function remove() {
      this.parent.removeChild(this.el);
    },
    fadeIn: function fadeIn() {
      this.el.offsetWidth;
      this.el.style.opacity = this.instance.options.bgOpacity;
    },
    fadeOut: function fadeOut() {
      this.el.style.opacity = 0;
    }
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  // Translate z-axis to fix CSS grid display issue in Chrome:
  // https://github.com/kingdido999/zooming/issues/42
  var TRANSLATE_Z = 0;

  var target = {
    init: function init(el, instance) {
      this.el = el;
      this.instance = instance;
      this.srcThumbnail = this.el.getAttribute('src');
      this.srcset = this.el.getAttribute('srcset');
      this.srcOriginal = getOriginalSource(this.el);
      this.rect = this.el.getBoundingClientRect();
      this.translate = null;
      this.scale = null;
      this.styleOpen = null;
      this.styleClose = null;
    },
    zoomIn: function zoomIn() {
      var _instance$options = this.instance.options,
          zIndex = _instance$options.zIndex,
          enableGrab = _instance$options.enableGrab,
          transitionDuration = _instance$options.transitionDuration,
          transitionTimingFunction = _instance$options.transitionTimingFunction;

      this.translate = this.calculateTranslate();
      this.scale = this.calculateScale();

      this.styleOpen = {
        position: 'relative',
        zIndex: zIndex + 1,
        cursor: enableGrab ? cursor.grab : cursor.zoomOut,
        transition: 'transform\n        ' + transitionDuration + 's\n        ' + transitionTimingFunction,
        transform: 'translate3d(' + this.translate.x + 'px, ' + this.translate.y + 'px, ' + TRANSLATE_Z + 'px)\n        scale(' + this.scale.x + ',' + this.scale.y + ')',
        height: this.rect.height + 'px',
        width: this.rect.width + 'px'

        // Force layout update
      };this.el.offsetWidth;

      // Trigger transition
      this.styleClose = setStyle(this.el, this.styleOpen, true);
    },
    zoomOut: function zoomOut() {
      // Force layout update
      this.el.offsetWidth;

      setStyle(this.el, { transform: 'none' });
    },
    grab: function grab(x, y, scaleExtra) {
      var windowCenter = getWindowCenter();
      var dx = windowCenter.x - x,
          dy = windowCenter.y - y;


      setStyle(this.el, {
        cursor: cursor.zoomOut,
        transform: 'translate3d(\n        ' + (this.translate.x + dx) + 'px, ' + (this.translate.y + dy) + 'px, ' + TRANSLATE_Z + 'px)\n        scale(' + (this.scale.x + scaleExtra) + ',' + (this.scale.y + scaleExtra) + ')'
      });
    },
    move: function move(x, y, scaleExtra) {
      var windowCenter = getWindowCenter();
      var dx = windowCenter.x - x,
          dy = windowCenter.y - y;


      setStyle(this.el, {
        transition: 'transform',
        transform: 'translate3d(\n        ' + (this.translate.x + dx) + 'px, ' + (this.translate.y + dy) + 'px, ' + TRANSLATE_Z + 'px)\n        scale(' + (this.scale.x + scaleExtra) + ',' + (this.scale.y + scaleExtra) + ')'
      });
    },
    restoreCloseStyle: function restoreCloseStyle() {
      setStyle(this.el, this.styleClose);
    },
    restoreOpenStyle: function restoreOpenStyle() {
      setStyle(this.el, this.styleOpen);
    },
    upgradeSource: function upgradeSource() {
      if (this.srcOriginal) {
        var parentNode = this.el.parentNode;

        if (this.srcset) {
          this.el.removeAttribute('srcset');
        }

        var temp = this.el.cloneNode(false);

        // Force compute the hi-res image in DOM to prevent
        // image flickering while updating src
        temp.setAttribute('src', this.srcOriginal);
        temp.style.position = 'fixed';
        temp.style.visibility = 'hidden';
        parentNode.appendChild(temp);

        // Add delay to prevent Firefox from flickering
        setTimeout(function updateSrc() {
          this.el.setAttribute('src', this.srcOriginal);
          parentNode.removeChild(temp);
        }.bind(this), 50);
      }
    },
    downgradeSource: function downgradeSource() {
      if (this.srcOriginal) {
        if (this.srcset) {
          this.el.setAttribute('srcset', this.srcset);
        }
        this.el.setAttribute('src', this.srcThumbnail);
      }
    },
    calculateTranslate: function calculateTranslate() {
      var windowCenter = getWindowCenter();
      var targetCenter = {
        x: this.rect.left + this.rect.width / 2,
        y: this.rect.top + this.rect.height / 2

        // The vector to translate image to the window center
      };return {
        x: windowCenter.x - targetCenter.x,
        y: windowCenter.y - targetCenter.y
      };
    },
    calculateScale: function calculateScale() {
      var _el$dataset = this.el.dataset,
          zoomingHeight = _el$dataset.zoomingHeight,
          zoomingWidth = _el$dataset.zoomingWidth;
      var _instance$options2 = this.instance.options,
          customSize = _instance$options2.customSize,
          scaleBase = _instance$options2.scaleBase;


      if (!customSize && zoomingHeight && zoomingWidth) {
        return {
          x: zoomingWidth / this.rect.width,
          y: zoomingHeight / this.rect.height
        };
      } else if (customSize && (typeof customSize === 'undefined' ? 'undefined' : _typeof(customSize)) === 'object') {
        return {
          x: customSize.width / this.rect.width,
          y: customSize.height / this.rect.height
        };
      } else {
        var targetHalfWidth = this.rect.width / 2;
        var targetHalfHeight = this.rect.height / 2;
        var windowCenter = getWindowCenter();

        // The distance between target edge and window edge
        var targetEdgeToWindowEdge = {
          x: windowCenter.x - targetHalfWidth,
          y: windowCenter.y - targetHalfHeight
        };

        var scaleHorizontally = targetEdgeToWindowEdge.x / targetHalfWidth;
        var scaleVertically = targetEdgeToWindowEdge.y / targetHalfHeight;

        // The additional scale is based on the smaller value of
        // scaling horizontally and scaling vertically
        var scale = scaleBase + Math.min(scaleHorizontally, scaleVertically);

        if (customSize && typeof customSize === 'string') {
          // Use zoomingWidth and zoomingHeight if available
          var naturalWidth = zoomingWidth || this.el.naturalWidth;
          var naturalHeight = zoomingHeight || this.el.naturalHeight;
          var maxZoomingWidth = parseFloat(customSize) * naturalWidth / (100 * this.rect.width);
          var maxZoomingHeight = parseFloat(customSize) * naturalHeight / (100 * this.rect.height);

          // Only scale image up to the specified customSize percentage
          if (scale > maxZoomingWidth || scale > maxZoomingHeight) {
            return {
              x: maxZoomingWidth,
              y: maxZoomingHeight
            };
          }
        }

        return {
          x: scale,
          y: scale
        };
      }
    }
  };

  function getWindowCenter() {
    var docEl = document.documentElement;
    var windowWidth = Math.min(docEl.clientWidth, window.innerWidth);
    var windowHeight = Math.min(docEl.clientHeight, window.innerHeight);

    return {
      x: windowWidth / 2,
      y: windowHeight / 2
    };
  }

  /**
   * Zooming instance.
   */

  var Zooming = function () {
    /**
     * @param {Object} [options] Update default options if provided.
     */
    function Zooming(options) {
      classCallCheck(this, Zooming);

      this.target = Object.create(target);
      this.overlay = Object.create(overlay);
      this.handler = Object.create(handler);
      this.body = document.body;

      this.shown = false;
      this.lock = false;
      this.released = true;
      this.lastScrollPosition = null;
      this.pressTimer = null;

      this.options = _extends({}, DEFAULT_OPTIONS, options);
      this.overlay.init(this);
      this.handler.init(this);
    }

    /**
     * Make element(s) zoomable.
     * @param  {string|Element} el A css selector or an Element.
     * @return {this}
     */


    createClass(Zooming, [{
      key: 'listen',
      value: function listen$$1(el) {
        if (typeof el === 'string') {
          var els = document.querySelectorAll(el);
          var i = els.length;

          while (i--) {
            this.listen(els[i]);
          }
        } else if (el.tagName === 'IMG') {
          el.style.cursor = cursor.zoomIn;
          listen(el, 'click', this.handler.click);

          if (this.options.preloadImage) {
            loadImage(getOriginalSource(el));
          }
        }

        return this;
      }

      /**
       * Update options or return current options if no argument is provided.
       * @param  {Object} options An Object that contains this.options.
       * @return {this|this.options}
       */

    }, {
      key: 'config',
      value: function config(options) {
        if (options) {
          _extends(this.options, options);
          this.overlay.updateStyle(this.options);
          return this;
        } else {
          return this.options;
        }
      }

      /**
       * Open (zoom in) the Element.
       * @param  {Element} el The Element to open.
       * @param  {Function} [cb=this.options.onOpen] A callback function that will
       * be called when a target is opened and transition has ended. It will get
       * the target element as the argument.
       * @return {this}
       */

    }, {
      key: 'open',
      value: function open(el) {
        var _this = this;

        var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.onOpen;

        if (this.shown || this.lock) return;

        var target$$1 = typeof el === 'string' ? document.querySelector(el) : el;

        if (target$$1.tagName !== 'IMG') return;

        this.options.onBeforeOpen(target$$1);

        this.target.init(target$$1, this);

        if (!this.options.preloadImage) {
          var srcOriginal = this.target.srcOriginal;


          if (srcOriginal != null) {
            this.options.onImageLoading(target$$1);
            loadImage(srcOriginal, this.options.onImageLoaded);
          }
        }

        this.shown = true;
        this.lock = true;

        this.target.zoomIn();
        this.overlay.insert();
        this.overlay.fadeIn();

        listen(document, 'scroll', this.handler.scroll);
        listen(document, 'keydown', this.handler.keydown);

        if (this.options.closeOnWindowResize) {
          listen(window, 'resize', this.handler.resizeWindow);
        }

        var onOpenEnd = function onOpenEnd() {
          listen(target$$1, 'transitionend', onOpenEnd, false);
          _this.lock = false;
          _this.target.upgradeSource();

          if (_this.options.enableGrab) {
            toggleGrabListeners(document, _this.handler, true);
          }

          cb(target$$1);
        };

        listen(target$$1, 'transitionend', onOpenEnd);

        return this;
      }

      /**
       * Close (zoom out) the Element currently opened.
       * @param  {Function} [cb=this.options.onClose] A callback function that will
       * be called when a target is closed and transition has ended. It will get
       * the target element as the argument.
       * @return {this}
       */

    }, {
      key: 'close',
      value: function close() {
        var _this2 = this;

        var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.onClose;

        if (!this.shown || this.lock) return;

        var target$$1 = this.target.el;

        this.options.onBeforeClose(target$$1);

        this.lock = true;
        this.body.style.cursor = cursor.default;
        this.overlay.fadeOut();
        this.target.zoomOut();

        listen(document, 'scroll', this.handler.scroll, false);
        listen(document, 'keydown', this.handler.keydown, false);

        if (this.options.closeOnWindowResize) {
          listen(window, 'resize', this.handler.resizeWindow, false);
        }

        var onCloseEnd = function onCloseEnd() {
          listen(target$$1, 'transitionend', onCloseEnd, false);

          _this2.shown = false;
          _this2.lock = false;

          _this2.target.downgradeSource();

          if (_this2.options.enableGrab) {
            toggleGrabListeners(document, _this2.handler, false);
          }

          _this2.target.restoreCloseStyle();
          _this2.overlay.remove();

          cb(target$$1);
        };

        listen(target$$1, 'transitionend', onCloseEnd);

        return this;
      }

      /**
       * Grab the Element currently opened given a position and apply extra zoom-in.
       * @param  {number}   x The X-axis of where the press happened.
       * @param  {number}   y The Y-axis of where the press happened.
       * @param  {number}   scaleExtra Extra zoom-in to apply.
       * @param  {Function} [cb=this.options.onGrab] A callback function that
       * will be called when a target is grabbed and transition has ended. It
       * will get the target element as the argument.
       * @return {this}
       */

    }, {
      key: 'grab',
      value: function grab(x, y) {
        var scaleExtra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.options.scaleExtra;
        var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.options.onGrab;

        if (!this.shown || this.lock) return;

        var target$$1 = this.target.el;

        this.options.onBeforeGrab(target$$1);

        this.released = false;
        this.target.grab(x, y, scaleExtra);

        var onGrabEnd = function onGrabEnd() {
          listen(target$$1, 'transitionend', onGrabEnd, false);
          cb(target$$1);
        };

        listen(target$$1, 'transitionend', onGrabEnd);

        return this;
      }

      /**
       * Move the Element currently grabbed given a position and apply extra zoom-in.
       * @param  {number}   x The X-axis of where the press happened.
       * @param  {number}   y The Y-axis of where the press happened.
       * @param  {number}   scaleExtra Extra zoom-in to apply.
       * @param  {Function} [cb=this.options.onMove] A callback function that
       * will be called when a target is moved and transition has ended. It will
       * get the target element as the argument.
       * @return {this}
       */

    }, {
      key: 'move',
      value: function move(x, y) {
        var scaleExtra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.options.scaleExtra;
        var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.options.onMove;

        if (!this.shown || this.lock) return;

        this.released = false;
        this.body.style.cursor = cursor.move;
        this.target.move(x, y, scaleExtra);

        var target$$1 = this.target.el;

        var onMoveEnd = function onMoveEnd() {
          listen(target$$1, 'transitionend', onMoveEnd, false);
          cb(target$$1);
        };

        listen(target$$1, 'transitionend', onMoveEnd);

        return this;
      }

      /**
       * Release the Element currently grabbed.
       * @param  {Function} [cb=this.options.onRelease] A callback function that
       * will be called when a target is released and transition has ended. It
       * will get the target element as the argument.
       * @return {this}
       */

    }, {
      key: 'release',
      value: function release() {
        var _this3 = this;

        var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.onRelease;

        if (!this.shown || this.lock) return;

        var target$$1 = this.target.el;

        this.options.onBeforeRelease(target$$1);

        this.lock = true;
        this.body.style.cursor = cursor.default;
        this.target.restoreOpenStyle();

        var onReleaseEnd = function onReleaseEnd() {
          listen(target$$1, 'transitionend', onReleaseEnd, false);
          _this3.lock = false;
          _this3.released = true;
          cb(target$$1);
        };

        listen(target$$1, 'transitionend', onReleaseEnd);

        return this;
      }
    }]);
    return Zooming;
  }();


  function toggleGrabListeners(el, handler$$1, add) {
    var types = ['mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend'];

    types.forEach(function toggleListener(type) {
      listen(el, type, handler$$1[type], add);
    });
  }

  return Zooming;

}));
      var img = new Zooming();
      img.listen("img");
    </script>
  </body>
</html>
